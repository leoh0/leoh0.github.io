<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ip on &gt; /dev/null</title>
    <link>https://leoh0.github.io/tags/ip/</link>
    <description>Recent content in ip on &gt; /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Aug 2020 01:12:11 +0900</lastBuildDate>
    
	<atom:link href="https://leoh0.github.io/tags/ip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>One hidden feature and one hidden problem in kubernetes</title>
      <link>https://leoh0.github.io/post/2020-08-08-one-hidden-feature-and-one-hidden-problem-in-kubernetes/</link>
      <pubDate>Sat, 08 Aug 2020 01:12:11 +0900</pubDate>
      
      <guid>https://leoh0.github.io/post/2020-08-08-one-hidden-feature-and-one-hidden-problem-in-kubernetes/</guid>
      <description>kubernetes에 다양한 외부 네트워크 연동 방법 kubernetes 는 어플리케이션을 외부에 연계하기 위해 ingress, service 등의 기능들을 제공합니다. 각각 ingress 는 L7 에 가까운 기능 그리고 service 는 L4 에 가까운 기능을 제공합니다.
일반적인 외부에 연동하는 방법들을 살펴보면 아래와 같습니다.
ingress는 보통 LB의 ip는 지정되어 있고 특정한 포트들을 지정해서 서비스 합니다. 80, 443과 같은 http, https 와 같은 포트를 서비스 하고 물론 tcp, udp등을 지원 하나 포트가 변경될때마다 ingress 의 controller 들이 다시 로딩되야 하여 포트를 추가하기는 번거롭습니다.</description>
    </item>
    
    <item>
      <title>How to use static ip in kubernetes nginx ingress without default backend</title>
      <link>https://leoh0.github.io/post/2019-09-24-how-to-use-static-ip-in-kubernetes-nginx-ingress-without-default-backend/</link>
      <pubDate>Tue, 24 Sep 2019 20:55:44 +0900</pubDate>
      
      <guid>https://leoh0.github.io/post/2019-09-24-how-to-use-static-ip-in-kubernetes-nginx-ingress-without-default-backend/</guid>
      <description>kubernetes ingress는 일반적으로 virtual host, virtual path등을 위한 서비스들을 제공하고 이는 DNS기반으로 작동되게 되어 있습니다.
만약 이런 ingress를 ip기반으로 사용하고 싶다고 하더라도 일반적으로 ingress validation에 막혀있습니다.
그래서 일반적으로는 nginx ingress static-ip example이런 예제와 같이 default backend를 통해 ip로 들어오는 리퀘스트가 처리 됩니다.
그렇다면 진짜로 ip로 들어오는 리퀘스트를 default backend가 아닌 다른 service로 연결할 수 없을까요? 물론 이 포스트를 쓰는 목적이지만 제한적이지만 답은 있습니다.
여기서부터는 해설 입니다.
해설 우선 힌트는 위의 ingress validation 라고 할 수 있는데, 뭐냐하면 사실 위에서 ParseIP를 통해 ip address가 파싱되는지를 확인해서 이로 설정되는 것을 막고 있지만 실제 ip address는 다양한 방법으로 표기 가능합니다.</description>
    </item>
    
    <item>
      <title>가장 변태적인 linux command</title>
      <link>https://leoh0.github.io/post/2015-04-24-gajang-byeontaejeogin-linux-command/</link>
      <pubDate>Fri, 24 Apr 2015 00:28:38 +0900</pubDate>
      
      <guid>https://leoh0.github.io/post/2015-04-24-gajang-byeontaejeogin-linux-command/</guid>
      <description>ip command 는 linux network 쪽을 위해 굉장히 많이 사용되는 커맨드 이다.
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename where OBJECT := { link | addr | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics | token } OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | bridge | link } | -4 | -6 | -I | -D | -B | -0 | -l[oops] { maximum-addr-flush-attempts } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size]} 이 커맨드의 가장 변태적이라고 생각한 부분은 다음이다.</description>
    </item>
    
  </channel>
</rss>