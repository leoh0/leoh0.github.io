<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#111111">
	<meta name="msapplication-TileColor" content="#111111">

<meta itemprop="name" content="Kubernetes Prometheus Metric Aggregation by Daemonset, Statefulset, Deployment Walkthrough">
<meta itemprop="description" content="Big Fantastic PromQL">


<meta itemprop="datePublished" content="2018-10-09T01:42:33&#43;09:00" />
<meta itemprop="dateModified" content="2018-10-09T01:42:33&#43;09:00" />
<meta itemprop="wordCount" content="2795">

  <meta itemprop="image" content="http://leoh0.github.io/images/Grafana%20-%20Aggregation%202018-10-09%2003-57-21.png">



<meta itemprop="keywords" content="k8s,kubernetes,prometheus,promql,metric,aggregation,daemonset,statefulset,deployment,walkthrough," />
<meta property="og:title" content="Kubernetes Prometheus Metric Aggregation by Daemonset, Statefulset, Deployment Walkthrough" />
<meta property="og:description" content="Big Fantastic PromQL" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leoh0.github.io/post/2018-10-09-kubernetes-prometheus-metric-aggregation-by-daemonset-statefulset-deployment-walkthrough/" />

<meta property="og:image" content="http://leoh0.github.io/images/Grafana%20-%20Aggregation%202018-10-09%2003-57-21.png" />
<meta property="article:published_time" content="2018-10-09T01:42:33&#43;09:00"/>
<meta property="article:modified_time" content="2018-10-09T01:42:33&#43;09:00"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://leoh0.github.io/images/Grafana%20-%20Aggregation%202018-10-09%2003-57-21.png"/>

<meta name="twitter:title" content="Kubernetes Prometheus Metric Aggregation by Daemonset, Statefulset, Deployment Walkthrough"/>
<meta name="twitter:description" content="Big Fantastic PromQL"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Kubernetes Prometheus Metric Aggregation by Daemonset, Statefulset, Deployment Walkthrough</title>
	<link rel="stylesheet" href="https://leoh0.github.io/css/style.min.31706917653d2b9e8410abd431f30ec4359a88a94fc87a63654779d87329edec.css" integrity="sha256-MXBpF2U9K56EEKvUMfMOxDWaiKlPyHpjZUd52HMp7ew=">
	<style>.bg-img {background-image: url('http://leoh0.github.io/images/Grafana%20-%20Aggregation%202018-10-09%2003-57-21.png');}</style>
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://leoh0.github.io/">&gt; /dev/null</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://leoh0.github.io/">Home</a>
					<a href="https://leoh0.github.io/post/">Posts</a>
					<a href="https://leoh0.github.io/about/aboutme">AboutMe</a>
					<a href="https://leoh0.github.io/blog/">.</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="img-btn" class="hdr-btn" title="Featured Image"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></button><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://leoh0.github.io/">Home</a></li>
			<li><a href="https://leoh0.github.io/post/">Posts</a></li>
			<li><a href="https://leoh0.github.io/about/aboutme">AboutMe</a></li>
			<li><a href="https://leoh0.github.io/blog/">.</a></li>
		</ul>
	</div>


	<div class="bg-img"></div>
	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Kubernetes Prometheus Metric Aggregation by Daemonset, Statefulset, Deployment Walkthrough</h1>
		<div class="content">
			

<figure>
    <img src="/images/Grafana%20-%20Aggregation%202018-10-09%2003-57-21.png"
         alt="Kubernetes Aggregation Metrics"/> <figcaption>
            <p>Kubernetes Aggregation Metrics</p>
        </figcaption>
</figure>


<h1 id="kubernetes-and-prometheus">kubernetes and prometheus<a href="#kubernetes-and-prometheus" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>최근 kubernetes에서 metric을 관리하는 것중 가장 유명한 것은 <code>prometheus</code>라고 할 수 있습니다. metric 관리방법으로 <code>heapster</code>를 사용할때 까지는 influxdb를 많이 사용하는 추세 였으나 앞으로 대채될 <code>metrics-server</code>는 <a href="https://github.com/kubernetes-incubator/metrics-server/issues/66">현재 in-memory sink밖에 없어서</a> 우선 기존에 influxdb를 사용하던것을 많이 안쓰게 될것 같습니다. 더욱이 <a href="https://github.com/DirectXMan12/k8s-prometheus-adapter">custom metric들에 대한 예제들이 prometheus로 제공</a>되고 있어서 prometheus로 metric관리가 통합될것으로 기대하고 있습니다.</p>

<p>이러한 prometheus로 kubernetes metric들을 수집하는 것은 대체로 크게 2가지 케이스 입니다.</p>

<ol>
<li>application 들의 metric 수집</li>
<li>container 단위 metric 수집</li>
</ol>

<p>오늘 이야기하고자 하는 주제는 2번과 같이 단위 container들로 수집된 metric들을 kubernetes 안에 pod들로 모아주고 이 pod들의 metric을 aggregation 하여 <code>daemonset</code>, <code>replicaset</code>, <code>deployment</code>, <code>statefulset</code> 과 같은 단위로 데이터를 보여줄 수 있도록 하기 위한 방법입니다.</p>

<h2 id="grafana-dashboard를-통해-살펴보는-기존-방법들">grafana dashboard를 통해 살펴보는 기존 방법들<a href="#grafana-dashboard를-통해-살펴보는-기존-방법들" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>실제 grafana dashboard들을 참고하면 마땅히 위와 같은 방식으로 aggregation한 대쉬보드를 많이 찾을 수가 없을 것입니다. 아래는 grafana dashboard 중에서 kubernetes와 관련된 그래프들을 중 다운로드 수가 높은 순으로 정렬해봤습니다. 이중 높은 순위 10개가 아래와 같습니다.</p>

<pre><code class="language-bash">$ (echo -e &quot;Download@Link@Name&quot; ; \
   curl -s 'https://grafana.com/api/dashboards?orderBy=name&amp;includeLogo=1&amp;page=1&amp;pageSize=100000&amp;filter=kubernetes' | \
   jq -cr '.items | sort_by(.downloads)[] | ((.downloads | tostring) + &quot;@https://grafana.com/dashboards/&quot; + (.id | tostring) + &quot;@&quot; + (.name))' | tail -n10) | \
   column -s '@' -t
Download  Link                                 Name
4603      https://grafana.com/dashboards/747   Kubernetes Pod Metrics
5430      https://grafana.com/dashboards/162   Kubernetes cluster monitoring (via Prometheus)
5904      https://grafana.com/dashboards/5303  Kubernetes Deployment (Prometheus)
6215      https://grafana.com/dashboards/3320  Kubernetes Node Exporter Full
6288      https://grafana.com/dashboards/3131  Kubernetes All Nodes
6466      https://grafana.com/dashboards/3119  Kubernetes cluster monitoring (via Prometheus)
7760      https://grafana.com/dashboards/5309  Kubernetes Capacity (Prometheus)
10884     https://grafana.com/dashboards/315   Kubernetes cluster monitoring (via Prometheus)
12866     https://grafana.com/dashboards/6663  Kubernetes pod and cluster monitoring (via Prometheus)
29231     https://grafana.com/dashboards/1621  Kubernetes cluster monitoring (via Prometheus)
</code></pre>

<p>이런 데이터를 몇개 보시면 알겠지만 대부분 node 혹은 pod의 이름으로만 검색해서 보도록 되어 있습니다.</p>

<p>예를 들어 아래와 같이 node와 pod 이름으로 검색해서 보던가
<a href="https://grafana.com/dashboards/747"><figure>
    <img src="/images/Grafana%20-%20Kubernetes%20Pod%20Metrics%202018-10-08%2023-13-12.png"
         alt="Kubernetes Pod Metrics"/> <figcaption>
            <p>Kubernetes Pod Metrics</p>
        </figcaption>
</figure>
</a></p>

<p>혹은 아래와 같이 node를 선택하고 그 안에서 pod들을 보도록 되어 있습니다.
<a href="https://grafana.com/dashboards/1621"><figure>
    <img src="/images/Grafana%20-%20Kubernetes%20cluster%20monitoring%20%28via%20Prometheus%29%202018-10-08%2023-10-43.png"
         alt="Kubernetes cluster monitoring (via Prometheus)"/> <figcaption>
            <p>Kubernetes cluster monitoring (via Prometheus)</p>
        </figcaption>
</figure>
</a></p>

<p>하지만 실제 우리가 kubernetes를 운영하다보면 kubernetes안의 object중 <code>daemonset</code>, <code>statefulset</code>, <code>deployment</code> 와 같은 단위로 선택해서 보고 싶은 경우들이 생기기에 이런 dashboard 만으로 부족하다는걸 알 수 있습니다.</p>

<h2 id="string-partial-match를-이용한-방법들">string partial match를 이용한 방법들<a href="#string-partial-match를-이용한-방법들" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>이런 경우 일반적으로 현재까지는 container이름들의 앞부분이 일치하는 것을 이용하여 이런 것을 <code>string partial match</code> 하여 해당 pod이 해당 deployment 들에 포함되는 것을 알아내는 식으로 구현 했습니다.</p>

<p>예를 들면 <code>calico-node</code> daemonset의 pod 이름들은 <code>calico-node-xxxxx</code>의 패턴이기 때문에 <code>calico-node-.*</code> 와 같은 regrex로 match를 유도하는 것입니다. 예를 들면 아래와 같습니다.</p>

<pre><code>rate(container_cpu_usage_seconds_total{namespace=&quot;$namespace&quot;,pod_name=~&quot;$daemonset.*&quot;}[1m])
</code></pre>

<p>실제 dashboard 들은 아래와 같은 것들을 참고해보면 이런 방식으로 많이 구현함을 알 수 있습니다.
<a href="https://grafana.com/dashboards/5330">Kubernetes StatefulSets (Prometheus)</a></p>

<p>하지만 이런 방법들은 정확하지 않고 좀 더 확실한 방법이 없나 찾게 됩니다. 왜냐하면 예를들어 만약 <code>calico-node-test</code> 와 같이 앞부분이 일치하는 다른 daemonset이 있다면 저런 regrex로 match 시키기 어려워 지기 때문입니다.</p>

<h2 id="label의-partial-match를-이용한-방법들">label의 partial match를 이용한 방법들<a href="#label의-partial-match를-이용한-방법들" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>아래 링크들과 같이 pod들의 label이 부분 일치하는것들을 이용해서 방법론들이 있었습니다. 이런 aggregation 하는 글들을 적용하면 정확한 pod을 찾아내기 위해서는 label을 열심히 준비해야 하는등 실제 상황에서는 좀 쓰기 불편한것들이 있었습니다.</p>

<p><a href="https://medium.com/@amimahloof/kubernetes-promql-prometheus-cpu-aggregation-walkthrough-2c6fd2f941eb">Kubernetes PromQL (Prometheus Query Language) CPU aggregation walkthrough</a></p>

<p><a href="https://5pi.de/2017/11/09/use-prometheus-vector-matching-to-get-kubernetes-utilization-across-any-pod-label/">Use Prometheus Vector Matching to get Kubernetes Utilization across any Pod Label</a></p>

<p>그래서 이런 부분 일치 시키는 방법보다 kubernetes가 실제 pod을 관리하는 방법과 가장 유사하게 수집이 되면 좋겠다고 생각할 수 있습니다.</p>

<h1 id="prometheus의-pod-metric을-위한-raw-데이터">prometheus의 pod metric을 위한 raw 데이터<a href="#prometheus의-pod-metric을-위한-raw-데이터" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>우선 pod들의 데이터를 aggregation하기 전에 container 단위로 수집되는 데이터들을 pod의 데이터로 환산하기 위한 방법을 설명합니다.</p>

<p>예를 들어 <a href="https://github.com/helm/charts/blob/master/stable/prometheus/values.yaml">helm chart default 값으로 labeling 값들이 구성</a>되어 있고 prometheus에서 pod 이름으로 예를 들어 데이터를 아래와 같이 수집한다고 했을때,</p>

<pre><code>container_cpu_usage_seconds_total{namespace=&quot;kube-system&quot;,pod_name=&quot;calico-node-xxxxx&quot;}
</code></pre>

<p>실제 확인되는 데이터들은 아래와 같습니다. 한 pod이지만 아래와 같이 3개의 데이터로 구성이 되어있는데 1개의 데이터가 아닌 이유는 cadvisor가 container단위로 수집하기 때문입니다. 수집하는 cadvisor 입장에서는 수집되는 데이터는 container기준으로만 수집이 되기 때문에 아래와 같습니다. 아래 calico-node 같은 경우 1개의 pause container와 2개의 conatiner(side car)로 구성되어 있기 때문에 3개 입니다.</p>

<pre><code>container_cpu_usage_seconds_total{
    beta_kubernetes_io_arch=&quot;amd64&quot;,
    beta_kubernetes_io_fluentd_ds_ready=&quot;true&quot;,
    beta_kubernetes_io_os=&quot;linux&quot;,
    container_name=&quot;POD&quot;,
    cpu=&quot;total&quot;,
    id=&quot;/system.slice/docker-9e11fe23188ab8df11e6695fd56567df63ff7d0709b0be1d892d5f32283a61af.scope&quot;,
    image=&quot;k8s.gcr.io/pause-amd64:3.1&quot;,
    instance=&quot;kubernetes-hostname&quot;,
    job=&quot;kubernetes-nodes-cadvisor&quot;,
    kubernetes_io_hostname=&quot;kubernetes-hostname&quot;,
    name=&quot;k8s_POD_calico-node-xxxxx_kube-system_1c2a925f-c609-11e8-9756-fa163eae1e89_0&quot;,
    namespace=&quot;kube-system&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
} 0.019708013

container_cpu_usage_seconds_total{
    beta_kubernetes_io_arch=&quot;amd64&quot;,
    beta_kubernetes_io_fluentd_ds_ready=&quot;true&quot;,
    beta_kubernetes_io_os=&quot;linux&quot;,
    container_name=&quot;calico-node&quot;,
    cpu=&quot;total&quot;,
    id=&quot;/system.slice/docker-b12ea25db1b81117c8f21791b94c627f10bb1fed8625fe6c6c94b29b26325c31.scope&quot;,
    image=&quot;quay.io/calico/node@sha256:563e45196382727b7e3d97640fa88955c75e7210f3bf1870140fa717f9b73b92&quot;,
    instance=&quot;kubernetes-hostname&quot;,
    job=&quot;kubernetes-nodes-cadvisor&quot;,
    kubernetes_io_hostname=&quot;kubernetes-hostname&quot;,
    name=&quot;k8s_calico-node_calico-node-xxxxx_kube-system_1c2a936e-c609-11e8-9756-fa163eae1e89_0&quot;,
    namespace=&quot;kube-system&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}    3317.174431967

container_cpu_usage_seconds_total{
    beta_kubernetes_io_arch=&quot;amd64&quot;,
    beta_kubernetes_io_fluentd_ds_ready=&quot;true&quot;,
    beta_kubernetes_io_os=&quot;linux&quot;,
    container_name=&quot;install-cni&quot;,
    cpu=&quot;total&quot;,
    id=&quot;/system.slice/docker-c98388e79128f17b1c2544531df9b92e72b682015ab4ad896620a756ca345c0c.scope&quot;,
    image=&quot;quay.io/calico/cni@sha256:df90cb1d18182fe41aef0eea293c0045473749e64b8dfd3e420db1a39e5edb39&quot;,
    instance=&quot;kubernetes-hostname&quot;,
    job=&quot;kubernetes-nodes-cadvisor&quot;,
    kubernetes_io_hostname=&quot;kubernetes-hostname&quot;,
    name=&quot;k8s_install-cni_calico-node-xxxxx_kube-system_1c2a936e-c609-11e8-9756-fa163eae1e89_0&quot;,
    namespace=&quot;kube-system&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}   54.916640243
</code></pre>

<p>그래서 일반적으로 pod이라고 할 수 있는 단위는 namespace와 pod_name으로 지정된 단위라고 볼 수 있습니다. 이런 metric들은 일반적으로 아래와 같이 sum하면 하나의 pod의 metric으로 간주 할 수 있습니다. 아래와 같이 label matching을 제거하면 모든 namespace와 pod에 대해서 수집하게 됩니다.</p>

<pre><code>sum(
  rate(container_cpu_usage_seconds_total[1m])
) by (namespace, pod_name, kubernetes_io_hostname)
</code></pre>

<p>위의 결과는 아래와 같이 합쳐지고 이 값을 이후 pod의 metric으로 사용하게 됩니다.</p>

<pre><code>{
    kubernetes_io_hostname=&quot;kubernetes_hostname&quot;,
    namespace=&quot;kube-system&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}  0.009238304374996708
...
</code></pre>

<h1 id="kubernetes-안에서-pod이-어떻게-object들로-관리-되고-있는가">kubernetes 안에서 pod이 어떻게 object들로 관리 되고 있는가<a href="#kubernetes-안에서-pod이-어떻게-object들로-관리-되고-있는가" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>kubernetes안에서 pod은 그냥 생성 할 수도 있지만 대부분은 owner를 갖게 됩니다. 예외인 경우는 첫번째로는 staticpod 입니다. staticpod은 kubelet과 같은 특수한 agent를 통해 lifecycle이 관리 되고 있기에 owner가 필요없습니다. 두번째로는 그냥 pod 입니다. 이 pod은 owner가 없어서 관리되지 않기에 삭제시 재생성되지 않고 바로 삭제됩니다. 이런 경우 빼고 대부분 확인해 보면 모든 pod들은 owner들을 가지고 있고 이 owner들로 우리는 aggregation 가능 합니다.</p>

<p>예를 들면 아래와 같이 <code>metadata.ownerReferences</code> 를 참고하시면 이게 해당 pod이 어떤 object(daemonset, statefulset, deployment)에 속해 있는지 알 수 있습니다. 예를 들면 이걸 기준으로 아래와 같이 <code>calico-node</code> 라는 <code>daemonset</code>은 아래의 pod을 가지고(관리하고) 있다고 알 수 있고 우리는 이런 기준으로 aggregation 가능함을 알게 됩니다.</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: true
    controller: true
    kind: DaemonSet
    name: calico-node
    ...
spec:
  containers:
...
</code></pre>

<p>즉, 이런 ownerReferences를 갖는 pod들은 모두 해당 daemonset에 포함됨으로 이런 ownerReferences를 갖는 pod들을 aggregation하게 되면 그것이 이 daemonset의 데이터가 됨을 알 수 있습니다.</p>

<h1 id="prometheus-데이터로-pod을-aggregation-하는-방법">prometheus 데이터로 pod을 aggregation 하는 방법<a href="#prometheus-데이터로-pod을-aggregation-하는-방법" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>앞서 말한것 처럼 pod의 aggregation을 하기 위해서는 ownerreference를 수집해야합니다. 이를 위해 <code>kube-state-metric</code> 프로젝트를 사용하면 됩니다. 일반적으로 helm을 이용해 prometheus를 설치했다면 기본으로 설정되어 있습니다. kube-state-metric을 이용하면 deployment들의 개수 상태등과 같은 kubernetes object에 대한 통계를 수집할수 있습니다. 하지만 이보다 이 글에서 더 중요하게 생각하는 부분은 다음과 같습니다.</p>

<blockquote>
<p>kube-state-metric은 pod들을 aggregation 하기 위한 metadata들을 제공</p>
</blockquote>

<p>일반적으로 prometheus에 수집되는 metric 들은 counter, gauge, histogram과 일반적으로 그 값(value)이 특정한 의미를 갖는 경우들입니다. 하지만 여기서 말하는 이런 metadata들은 value는 전부 1입니다. 왜냐하면 이 metadata들은 해당 vector 안에 label들의 연관관계를 보이기 위함이 주 목적이기 때문입니다.</p>

<p>이런 kube-state-metric을 통해 수집되는 metadata들중 우리에게 필요한 값들은 <code>kube_pod_owner</code>, <code>kube_replicaset_owner</code>등과 같습니다. 이런 metric들은 실제로 값을 찍어보면 아래와 같습니다. 모두 그 value가 1임을 알 수 있습니다.</p>

<pre><code>kube_pod_owner{
    app=&quot;prometheus&quot;,
    chart=&quot;prometheus-7.0.0&quot;,
    component=&quot;kube-state-metrics&quot;,
    heritage=&quot;Tiller&quot;,
    job=&quot;kubernetes-service-endpoints&quot;,
    kubernetes_name=&quot;prometheus-kube-state-metrics&quot;,
    kubernetes_namespace=&quot;kube-system&quot;,
    namespace=&quot;kube-system&quot;,
    owner_is_controller=&quot;true&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;calico-node&quot;,
    pod=&quot;calico-node-xxxxx&quot;,
    release=&quot;prometheus&quot;
} 1
</code></pre>

<p>위에서 말했지만 다시 한번 강조하면 여기서 결국 중요한 label은 <code>namespace</code>, <code>owner_name</code>, <code>pod</code>, <code>owner_kind</code>와 같은 데이터 입니다. 이 값들을 알면 pod의 데이터를 이 값을 기준으로 aggregation 시킬 수 있기 때문입니다. 즉 위의 값은 <code>pod=&quot;calico-node-xxxxx&quot;</code> 와 같은 pod은 <code>owner_name=&quot;calico-node&quot;</code> 와 같은 daemonset으로 aggregation 가능하다는 것을 알 수 있습니다.</p>

<p>그리고 이런 값들은 아래와 같이 value는 중요하지 않기때문에 필요한 label들만 아래와 같이 <code>max</code> 같은 함수로 추려낼 수 있습니다.</p>

<pre><code>max(
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>위와 같이 수행하면 아래와 같이 <code>owner_name</code>와 <code>pod</code>의 관계들이 나오게 됩니다.</p>

<pre><code>{
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;calico-node&quot;,
    pod=&quot;calico-node-xxxxx&quot;
}    1
{
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;csi-rbdplugin&quot;,
    pod=&quot;csi-rbdplugin-xxxxx&quot;
}   1
{
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;ReplicaSet&quot;,
    owner_name=&quot;calicoctl-5cb5cc8c56&quot;,
    pod=&quot;calicoctl-5cb5cc8c56-xxxxx&quot;
}    1
...
</code></pre>

<p>그렇다면 이제 위와 같은 metadata에 aggregation될 metric 들을 살펴보겠습니다. 위에서 한번 언급한 pod단위로 수집된 container의 metric은 아래와 같습니다.</p>

<pre><code>sum(
  rate(container_cpu_usage_seconds_total[1m])
) by (namespace, pod_name, kubernetes_io_hostname)
</code></pre>

<p>다시한번 이값을 살펴보면 아래와 같이 <code>kubernetes_io_hostname</code>, <code>namespace</code>, <code>pod_name</code> 으로 정리됩니다.</p>

<pre><code>{
    kubernetes_io_hostname=&quot;kubernetes_hostname&quot;,
    namespace=&quot;kube-system&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}  0.00312516730000425
...
</code></pre>

<p>이 값은 위에서 수집된 <code>kube_pod_owner</code>의 label과 차이가 있음을 알 수 있습니다. <code>kube_pod_owner</code>에서 pod은 <code>pod</code>인데 여기에서는 <code>pod_name</code> 이기 때문입니다. 그래서 이 값을 aggregation(<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching">vector matching</a>) 하기 위해서는 한쪽 metric의 label에 동일한 label을 만들어야 합니다. 그러기 위해서 prometheus의 <a href="https://prometheus.io/docs/prometheus/latest/querying/functions/#label_replace">label_replace</a>를 사용합니다. 이 function을 이용하면 prometheus vector들의 label을 재설정 가능합니다.</p>

<p>그래서 이를 위해 <code>container_cpu_usage_seconds_total</code>의 label 중 <code>pod_name</code> label을 <code>pod</code>으로 복사합니다. 이러면 <code>kube_pod_owner</code>의 <code>pod</code> label과 vector matching 시킬 수 있기 때문입니다.</p>

<p>그래서 아래와 같이 label을 복사합니다.</p>

<pre><code>label_replace(
  sum(
    rate(container_cpu_usage_seconds_total[1m])
  ) by (namespace, pod_name, kubernetes_io_hostname)
  ,&quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>그러면 아래와 같이 <code>pod</code> label이 추가 됩니다.</p>

<pre><code>{
    kubernetes_io_hostname=&quot;kubernetes_hostname&quot;,
    namespace=&quot;kube-system&quot;,
    pod=&quot;calico-node-xxxxx&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}  0.00312516730000425
...
</code></pre>

<p>이렇게 까지 진행하면 이제 아래와 같이 metadata와 metric을 아래와 같이 aggregation 할 수 있습니다.</p>

<pre><code>max(
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
*
on(pod, namespace)
group_right(owner_name, owner_kind)
label_replace(
  sum(
    rate(container_cpu_usage_seconds_total[1m])
  ) by (namespace, pod_name, kubernetes_io_hostname)
  ,&quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>위의 vector matching은 5가지로 쪼개서 이해할 수 있습니다.</p>

<pre><code># 1
max(
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)

# 2
*

# 3
on(pod, namespace)

# 4
group_right(owner_name, owner_kind)

# 5
label_replace(
  sum(
    rate(container_cpu_usage_seconds_total[1m])
  ) by (namespace, pod_name, kubernetes_io_hostname)
  ,&quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>위는 두 벡터(위의 #1과 #5)중에서 <code>on(pod, namespace)</code> 가 동일한 벡터를 <code>*(multiplication)</code> 와 같이 곱하고 이 결과를 #5 벡터값에 <code>group_right(owner_name, owner_kind)</code>를 추가한다는 의미입니다.  자세한건 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#many-to-one-and-one-to-many-vector-matches">Many-to-one and one-to-many vector matches</a> 를 참고하시면 됩니다.</p>

<p>이렇게 하면 결과값은 아래와 같이 <code>owner_name</code> 을 기준으로 pod들 metric이 aggregation 되어 출력됩니다.</p>

<pre><code>{
    kubernetes_io_hostname=&quot;kubernetes_hostname&quot;,
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;calico-node&quot;,
    pod=&quot;calico-node-xxxxx&quot;,
    pod_name=&quot;calico-node-xxxxx&quot;
}  0.00312516730000425
{
    kubernetes_io_hostname=&quot;kubernetes_hostname&quot;,
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;calico-node&quot;,
    pod=&quot;calico-node-yyyyy&quot;,
    pod_name=&quot;calico-node-yyyyy&quot;
}  0.00231112232123345
...
</code></pre>

<p>이 값은 아래와 같이 AVG 등의 함수를 이용하면 해당 값들을 평균값들도 생성가능하게 됩니다.</p>

<pre><code>avg(
  max(
    kube_pod_owner
  ) by (owner_name, owner_kind, pod, namespace)
  *
  on(pod, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    sum(
      rate(container_cpu_usage_seconds_total[1m])
    ) by (namespace, pod_name, kubernetes_io_hostname)
    ,&quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
  )
) by (namespace, owner_kind, owner_name)
</code></pre>

<p>결과는 아래와 같이 모든 <code>replicaset</code>, <code>daemonset</code>, <code>statefulset</code> pod들을 aggregation 하고 평균값을 내줄 수 있습니다.</p>

<pre><code>{
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;DaemonSet&quot;,
    owner_name=&quot;calico-node&quot;
}   0.01108754473353368
{
    namespace=&quot;rook-ceph&quot;,
    owner_kind=&quot;ReplicaSet&quot;,
    owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;
}  0.0036500768999985665
{
    namespace=&quot;kube-system&quot;,
    owner_kind=&quot;StatefulSet&quot;,
    owner_name=&quot;csi-rbdplugin-attacher&quot;
}  0.00247490775230173
...
</code></pre>

<h1 id="deployment로-aggregation-하기-위한-방법">deployment로 aggregation 하기 위한 방법<a href="#deployment로-aggregation-하기-위한-방법" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>daemonset과 statefulset은 위와 같은 방법들을 이용하면 쉽게 aggregation 가능 합니다. 다만 deployment와 같은 경우는 replicaset과 같은 ownerreference를 한번 더 거쳐야 합니다. (pod -&gt; replicaset -&gt; deployment) 다시 말해 다른 object와 달리 2단계의 ownerreference 체크가 필요합니다. 이 케이스를 설명하는 것은 이런 방법을 응용하면 이후에도 다양한 형태의 object들을 aggregation 할 수 있다고 생각하기 때문입니다.</p>

<p>다만 이부분 부터는 kube-state-metrics 에 <a href="https://github.com/kubernetes/kube-state-metrics/commit/991e511f11a9bb201b8f10f6dc4c5703c0065e06">add kube_replicatset_owner metric</a>과 같은 커밋이 있어야 합니다. 왜냐하면 아래에서 나오는 <code>kube_replicaset_owner</code>는 위의 커밋이 있어야 수집되기 때문입니다. 이건 kube-state-metrics 다음버전에 들어갈 것으로 예상되고 아직은 추가 되지 않은 상태입니다. 대충 해당 커밋을 포함해서 이미지를 빌드해서 사용하면 됩니다. 아니면 미리 빌드해둔 <code>leoh0/kube-state-metrics:latest</code> 이미지를 쓰셔도 됩니다.</p>

<p>그렇다면 <code>kube_pod_owner</code> 와 <code>kube_replicaset_owner</code> 를 어떻게 vector matching 하는지 설명 드리겠습니다. 즉, pod -&gt; replicaset -&gt; deployment 연계중 우선 replicaset -&gt; deployment 부터 조합하는 것입니다. 이런 metadata들을 먼저 vector matching하는 것은 아무래도 이런 metadata가 metric 수보다는 적기에 먼저 연산하는 것이 유리하기 때문입니다.</p>

<p>이제 match할 <code>kube_pod_owner</code>는 위에서도 사용것과 같은 아래 값입니다.</p>

<pre><code>max(
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>이 결과중 아래와 같이 <code>ReplicaSet</code> 데이터가 있음을 확인 할 수 있습니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    owner_kind=&quot;ReplicaSet&quot;,
    owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;,
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot;
}    1
...
</code></pre>

<p>이런 위의 데이터와 연결할  <code>kube_replicaset_owner</code>를 살펴보면 아래와 같이 확인할 수 있습니다.</p>

<pre><code>max(
  kube_replicaset_owner
) by (namespace, owner_name, owner_kind, replicaset)
</code></pre>

<p>이 데이터는 아래와 같습니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a&quot;,
    replicaset=&quot;rook-ceph-mgr-a-88d56c679&quot;
}  1
</code></pre>

<p>즉, <code>kube_pod_owner</code>의 <code>owner_name</code> 가 <code>kube_replicaset_owner</code>의 <code>replicaset</code>와 일치 될경우(물론 namespace도 동일) vector가 매칭 될 수 있습니다.</p>

<p>그러면 이제 단순한 생각의 흐름으로 이 두 벡터를 매칭 시키는 방법을 설명드립니다. 쿼리를 최적화 하려면 다른 방법들도 가능하지만 다양한 방법들이 가능하다는 것을 설명드리고자 합니다.</p>

<p>우리가 원하는 결과물은 아래와 같습니다. <code>owner_kind</code> <code>owner_name</code>은 <code>kube_replicaset_owner</code>용 label value를 사용하고 <code>pod</code>은 <code>kube_pod_owner</code>의 label value를 사용하는 것입니다. 이런 metadata를 만들어야 나중에 pod metric을 아래 metadata에 match 시키면 deployment로 수집될 수 있기 때문입니다. 이를 간단히 설명하면 아래와 같습니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;, // kube_pod_owner, kube_replicaset_owner 동일
    owner_kind=&quot;Deployment&quot;, // kube_replicaset_owner 값
    owner_name=&quot;rook-ceph-mgr-a&quot;, // kube_replicaset_owner 값
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot; // kube_pod_owner 값
}   1
</code></pre>

<p>위와 같이 구성하기 위해 우선 kube_replicaset_owner를 -&gt; kube_pod_owner 로 매칭 시키도록 합니다. 결국 base는 <code>kube_pod_owner</code> 가 되기 때문에 이 owner_kind를 나중에 <code>Deployment</code>로 세팅하기 위한 값을 세팅합니다.</p>

<pre><code>label_replace(
  max(
    kube_replicaset_owner
  ) by (namespace, owner_name, owner_kind, replicaset)
  ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>이런 결과는 아래와 같이 <code>new_kind=&quot;Deployment&quot;</code> 가 생깁니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a&quot;,
    replicaset=&quot;rook-ceph-mgr-a-88d56c679&quot;
}  1
</code></pre>

<p>이제 나중에 <code>owner_name</code>도 나중에 덮어쓰기 위한 값을 세팅합니다. 왜냐하면 <code>kube_pod_owner</code>에 owner_name에 매칭하기 위해서 기존의 replicaset 을 owner_name으로 변경하기 때문에 미리 owner_name을 나중에 다시 사용하기 위해 <code>new_name</code>으로 복사해 두는 겁니다.</p>

<pre><code>label_replace(
  label_replace(
    max(
      kube_replicaset_owner
    ) by (namespace, owner_name, owner_kind, replicaset)
    ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
  )
  ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p><code>new_name=&quot;rook-ceph-mgr-a&quot;</code> 와 같이 추가 되어 있는 것을 알 수 있습니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    new_name=&quot;rook-ceph-mgr-a&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a&quot;,
    replicaset=&quot;rook-ceph-mgr-a-88d56c679&quot;
}  1
</code></pre>

<p>또, 아래와 같이 나중에 match시키기 위해 kube_pod_owner의 owner_name과 match하기 위해 replicaset값을 owner_name로 변경합니다.</p>

<pre><code>label_replace(
  label_replace(
    label_replace(
      max(
        kube_replicaset_owner
      ) by (namespace, owner_name, owner_kind, replicaset)
      ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
    )
    ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;replicaset&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>owner_name이 <code>owner_name=&quot;rook-ceph-mgr-a&quot;</code> -&gt; <code>owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;</code> 로 변경됩니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    new_name=&quot;rook-ceph-mgr-a&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;,
    replicaset=&quot;rook-ceph-mgr-a-88d56c679&quot;
}  1
</code></pre>

<p>이제 준비한 이 벡터를 kube_pod_owner 에 match합니다.</p>

<pre><code>label_replace(
  label_replace(
    label_replace(
      max(
        kube_replicaset_owner
      ) by (namespace, owner_name, owner_kind, replicaset)
      ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
    )
    ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;replicaset&quot;, &quot;(.+)&quot;
)
*
on(owner_name, namespace)
group_right(new_name, new_kind)
max(
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>결과는 아래와 같이 kube_pod_owner 벡터에 new_name과 new_kind가 추가되서 match됩니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    new_name=&quot;rook-ceph-mgr-a&quot;,
    owner_kind=&quot;ReplicaSet&quot;,
    owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;,
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot;
}   1
</code></pre>

<p>여기에서 우리는 new_kind를 우리가 원하는 owner_kind에 덮어씁니다.</p>

<pre><code>label_replace(
  label_replace(
    label_replace(
      label_replace(
        max(
          kube_replicaset_owner
        ) by (namespace, owner_name, owner_kind, replicaset)
        ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
      )
      ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
    )
    ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;replicaset&quot;, &quot;(.+)&quot;
  )
  *
  on(owner_name, namespace)
  group_right(new_name, new_kind)
  max(
    kube_pod_owner
  ) by (owner_name, owner_kind, pod, namespace)
  ,&quot;owner_kind&quot;, &quot;$1&quot;, &quot;new_kind&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>아래와 같이 <code>owner_kind=&quot;ReplicaSet&quot;</code> -&gt; <code>owner_kind=&quot;Deployment&quot;</code> 로 변경 됩니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    new_name=&quot;rook-ceph-mgr-a&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;,
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot;
}   1
</code></pre>

<p>또 비슷하게 new_name으로 owner_name을 덮어씁니다.</p>

<pre><code>label_replace(
  label_replace(
    label_replace(
      label_replace(
        label_replace(
          max(
            kube_replicaset_owner
          ) by (namespace, owner_name, owner_kind, replicaset)
          ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
        )
        ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
      )
      ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;replicaset&quot;, &quot;(.+)&quot;
    )
    *
    on(owner_name, namespace)
    group_right(new_name, new_kind)
    max(
      kube_pod_owner
    ) by (owner_name, owner_kind, pod, namespace)
    ,&quot;owner_kind&quot;, &quot;$1&quot;, &quot;new_kind&quot;, &quot;(.+)&quot;
  )
  ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;new_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>아래와 같이 <code>owner_name=&quot;rook-ceph-mgr-a-88d56c679&quot;</code> -&gt; <code>owner_name=&quot;rook-ceph-mgr-a&quot;</code> 로 변경 됩니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    new_kind=&quot;Deployment&quot;,
    new_name=&quot;rook-ceph-mgr-a&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a&quot;,
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot;
}   1
</code></pre>

<p>여기에서 사용할 <code>owner_name</code>, <code>owner_kind</code>, <code>pod</code>, <code>namespace</code> 만 추려냅니다.</p>

<pre><code>max(
  label_replace(
    label_replace(
      label_replace(
        label_replace(
          label_replace(
            max(
              kube_replicaset_owner
            ) by (namespace, owner_name, owner_kind, replicaset)
            ,&quot;new_kind&quot;, &quot;$1&quot;, &quot;owner_kind&quot;, &quot;(.+)&quot;
          )
          ,&quot;new_name&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
        )
        ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;replicaset&quot;, &quot;(.+)&quot;
      )
      *
      on(owner_name, namespace)
      group_right(new_name, new_kind)
      max(
        kube_pod_owner
      ) by (owner_name, owner_kind, pod, namespace)
      ,&quot;owner_kind&quot;, &quot;$1&quot;, &quot;new_kind&quot;, &quot;(.+)&quot;
    )
    ,&quot;owner_name&quot;, &quot;$1&quot;, &quot;new_name&quot;, &quot;(.+)&quot;
  )
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>아래와 같이 벡터가 추려진것을 확인 할 수 있습니다.</p>

<pre><code>{
    namespace=&quot;rook-ceph&quot;,
    owner_kind=&quot;Deployment&quot;,
    owner_name=&quot;rook-ceph-mgr-a&quot;,
    pod=&quot;rook-ceph-mgr-a-88d56c679-7kwgc&quot;
}   1
</code></pre>

<h1 id="grafana-에-kubernetes-aggregation-dashboard-만들기">grafana 에 kubernetes aggregation dashboard 만들기<a href="#grafana-에-kubernetes-aggregation-dashboard-만들기" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>우선 예제로 설명할 dashboard는 아래와 같습니다.</p>

<p><a href="http://leoh0.github.io/data/aggregation.json">download kubernetes aggregation grafana dashboard</a></p>

<figure>
    <img src="/images/Grafana%20-%20Aggregation%202018-10-09%2003-40-53.png"
         alt="Kubernetes Aggregation Metrics"/> <figcaption>
            <p>Kubernetes Aggregation Metrics</p>
        </figcaption>
</figure>


<p>우선 해당 dashboard를 사용하려면 <code>grafana/grafana:5.3.0-beta3</code> 와 같은 grafana 5.3.0 이상을 사용해야 합니다. 왜냐하면 prometheus의 <code>$__interval</code>과 같은 <a href="https://github.com/grafana/grafana/issues/7664">range query 옵션</a>을 넣었기 때문입니다. 만약 이전버전 grafana를 그대로 이용하실 분들은 그냥 <code>$__interval</code>과 같은 부분을 <code>1m</code> 과 같이 변경하면 사용 가능합니다. 하지만 이 query를 사용해야 보다 기간에 따른 적당한 양의 data를 가져올 수 있어 더욱 용이 합니다.</p>

<p>이 dashboard에서 사용한 metadata aggregation을 위해 아래와 같은 query문을 만들었습니다. 이 쿼리의 결과는 모든 pod, namespace들의 owner_name와 owner_kind들을 출력해줍니다.</p>

<pre><code>max(
  max(
    kube_replicaset_owner
  ) by (namespace, owner_name, owner_kind, replicaset)
  *
  on(replicaset, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    max(
      kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
    ) by (owner_name, pod, namespace)
    , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  or
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>이 쿼리는 아래와 같이 분리해서 해석할 수 있습니다. 우선 아래는 사실 위 챕터에서 replicaset -&gt; deployment match를 조금 더 튜닝한 버전입니다.</p>

<pre><code>max(
  kube_replicaset_owner
) by (namespace, owner_name, owner_kind, replicaset)
*
on(replicaset, namespace)
group_right(owner_name, owner_kind)
label_replace(
  max(
    kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
  ) by (owner_name, pod, namespace)
  , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>여기에 아래와같이 기존의 모든 pod들의 owner 관련 정보를 추가합니다.</p>

<pre><code>or
kube_pod_owner
</code></pre>

<p>dashboard에 대해서 간략히 설명하면 우선 다음과 같습니다.</p>

<p><code>ns</code> variables은 namespace를 의미하며 아래와 같은 결과에서 <code>&quot;^{namespace=\&quot;(.+?)\&quot;,.*$&quot;</code> 와 같은 regrex로 결과를 추출한 값입니다.</p>

<pre><code>max(
  max(
    kube_replicaset_owner
  ) by (namespace, owner_name, owner_kind, replicaset)
  *
  on(replicaset, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    max(
      kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
    ) by (owner_name, pod, namespace)
    , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  or
  kube_pod_owner
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p><code>kind</code> variables는 여기에 <code>{namespace=&quot;$ns&quot;}</code> 가 정의된 상태에서 검색 되도록 하고 <code>&quot;^.*owner_kind=\&quot;(.+?)\&quot;,.*$&quot;</code> 와 같이 추출합니다.</p>

<pre><code>max(
  max(
    kube_replicaset_owner{namespace=&quot;$ns&quot;}
  ) by (namespace, owner_name, owner_kind, replicaset)
  *
  on(replicaset, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    max(
      kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
    ) by (owner_name, pod, namespace)
    , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  or
  kube_pod_owner{namespace=&quot;$ns&quot;}
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p><code>on</code> variables는 여기에 <code>{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;}</code> 가 정의된 상태에서 검색되고 <code>&quot;^.*owner_name=\&quot;(.+?)\&quot;,.*$&quot;</code> 로 추출 되도록 합니다.</p>

<pre><code>max(
  max(
    kube_replicaset_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;}
  ) by (namespace, owner_name, owner_kind, replicaset)
  *
  on(replicaset, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    max(
      kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
    ) by (owner_name, pod, namespace)
    , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  or
  kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;}
) by (owner_name, owner_kind, pod, namespace)
</code></pre>

<p>실제 metric은 아래와 같습니다. 위의 쿼리에 보통 metric을 join 시키는 방식입니다.
각각 pod 각각의 상태와 avg 한 그래프를 배치시키는 방식입니다.</p>

<p>query A</p>

<pre><code>max(
  max(
    kube_replicaset_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;,owner_name=&quot;$on&quot;}
  ) by (namespace, owner_name, owner_kind, replicaset)
  *
  on(replicaset, namespace)
  group_right(owner_name, owner_kind)
  label_replace(
    max(
      kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
    ) by (owner_name, pod, namespace)
    , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
  )
  or
  kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;,owner_name=&quot;$on&quot;}
) by (owner_name, owner_kind, pod, namespace)
*
on(pod, namespace)
group_right(owner_kind, owner_name)
label_replace(
  sum by(pod_name, namespace, kubernetes_io_hostname) (
    rate(container_cpu_usage_seconds_total{namespace=&quot;$ns&quot;}[$__interval])
  ), &quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
)
</code></pre>

<p>query B</p>

<pre><code>avg(
  max(
    max(
      kube_replicaset_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;,owner_name=&quot;$on&quot;}
    ) by (namespace, owner_name, owner_kind, replicaset)
    *
    on(replicaset, namespace)
    group_right(owner_name, owner_kind)
    label_replace(
      max(
        kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;ReplicaSet&quot;}
      ) by (owner_name, pod, namespace)
      , &quot;replicaset&quot;, &quot;$1&quot;, &quot;owner_name&quot;, &quot;(.+)&quot;
    )
    or
    kube_pod_owner{namespace=&quot;$ns&quot;,owner_kind=&quot;$kind&quot;,owner_name=&quot;$on&quot;}
  ) by (owner_name, owner_kind, pod, namespace)
  *
  on(pod, namespace)
  group_right(owner_kind, owner_name)
  label_replace(
    sum by(pod_name, namespace, kubernetes_io_hostname) (
      rate(container_cpu_usage_seconds_total{namespace=&quot;$ns&quot;}[$__interval])
    ), &quot;pod&quot;, &quot;$1&quot;, &quot;pod_name&quot;, &quot;(.+)&quot;
  )
) by (owner_name, owner_kind, namespace)
</code></pre>

<p>실제 여기 있는 metric graph나 variable 같은 경우 최적화를 하지 않은 쿼리문이라서 속도가 느립니다. 이런식으로 많은 join(vector matching)을 하면 쿼리 성능에도 영향을 크게 미칩니다. 이건 그냥 복잡한 케이스 해결의 예시로 참고하시면 좋을 것 같습니다. 실제로 예를 들어 <code>namespace</code>나 <code>kind</code>를 variable로 정리하는 것은 더 간단한 쿼리를 사용합니다.</p>

<h1 id="결론">결론<a href="#결론" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>사실 여기까지 설명한것은 이런 기법들중 굉장히 일부분을 설명한 것입니다. 사실 prometheus를 kubernetes에 제대로 연동하기 위해서는 추가적인 metadata들을 더 수집하고 custom metric들을 위한 labeling 작업 등등 많은 부분들이 남아 있습니다. 다만 이런 방법들을 적용하면 기존에 만들지 못한 패턴들을 탐지할 수 있는 그래프들을 만들 단초가 될것으로 기대됩니다.</p>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://leoh0.github.io/"></a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://leoh0.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://leoh0.github.io/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js" integrity="sha256-eEQX9YRxUfhIwznPCssToGy7ZIsUg0NaKO1FVsTq1ps="></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-46519012-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
