<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#111111">
	<meta name="msapplication-TileColor" content="#111111">

<meta itemprop="name" content="immutable kubernetes by linuxkit">
<meta itemprop="description" content="linuxkit with kubernetes    &hellip; As a developer and sometimes system administrator, one of the scariest things I ever encounter is a server that’s been running for ages which has seen multiple upgrades of system and application software. &hellip; Need to upgrade? No problem. Build a new, upgraded system and throw the old one away. New app revision? Same thing. Build a server (or image) with a new revision and throw away the old ones.">


<meta itemprop="datePublished" content="2018-05-21T00:55:10&#43;09:00" />
<meta itemprop="dateModified" content="2018-05-21T00:55:10&#43;09:00" />
<meta itemprop="wordCount" content="2162">



<meta itemprop="keywords" content="linuxkit,docker,kubernetes,k8s,weave,cilium,calico,gcp,aws," />
<meta property="og:title" content="immutable kubernetes by linuxkit" />
<meta property="og:description" content="linuxkit with kubernetes    &hellip; As a developer and sometimes system administrator, one of the scariest things I ever encounter is a server that’s been running for ages which has seen multiple upgrades of system and application software. &hellip; Need to upgrade? No problem. Build a new, upgraded system and throw the old one away. New app revision? Same thing. Build a server (or image) with a new revision and throw away the old ones." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leoh0.github.io/post/2018-05-21-immutable-kubernetes/" />

<meta property="og:image" content="https://source.unsplash.com/collection/983219/2000x1322" />
<meta property="article:published_time" content="2018-05-21T00:55:10&#43;09:00"/>
<meta property="article:modified_time" content="2018-05-21T00:55:10&#43;09:00"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://source.unsplash.com/collection/983219/2000x1322"/>

<meta name="twitter:title" content="immutable kubernetes by linuxkit"/>
<meta name="twitter:description" content="linuxkit with kubernetes    &hellip; As a developer and sometimes system administrator, one of the scariest things I ever encounter is a server that’s been running for ages which has seen multiple upgrades of system and application software. &hellip; Need to upgrade? No problem. Build a new, upgraded system and throw the old one away. New app revision? Same thing. Build a server (or image) with a new revision and throw away the old ones."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>immutable kubernetes by linuxkit</title>
	<link rel="stylesheet" href="https://leoh0.github.io/css/style.min.31706917653d2b9e8410abd431f30ec4359a88a94fc87a63654779d87329edec.css" crossorigin="anonymous" integrity="sha256-MXBpF2U9K56EEKvUMfMOxDWaiKlPyHpjZUd52HMp7ew=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://leoh0.github.io/">&gt; /dev/null</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://leoh0.github.io/">Home</a>
					<a href="https://leoh0.github.io/post/">Posts</a>
					<a href="https://leoh0.github.io/about/aboutme">AboutMe</a>
					<a href="https://leoh0.github.io/blog/">.</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://leoh0.github.io/">Home</a></li>
			<li><a href="https://leoh0.github.io/post/">Posts</a></li>
			<li><a href="https://leoh0.github.io/about/aboutme">AboutMe</a></li>
			<li><a href="https://leoh0.github.io/blog/">.</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>immutable kubernetes by linuxkit</h1>
		<div class="content">
			

<figure>
    <img src="/images/lk-k8s.png"/> <figcaption>
            <h4>linuxkit with kubernetes</h4>
        </figcaption>
</figure>


<blockquote>
<p>&hellip;
As a developer and sometimes system administrator, one of the scariest things I ever encounter is a server that’s been running for ages which has seen multiple upgrades of system and application software.
&hellip;
Need to upgrade? No problem. Build a new, upgraded system and throw the old one away. New app revision? Same thing. Build a server (or image) with a new revision and throw away the old ones.
&hellip;</p>
</blockquote>

<p>Link <a href="http://chadfowler.com/2013/06/23/immutable-deployments.html">Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components - Chad Fowler</a></p>

<p>2013년 해당 글을 읽었을때만 해도 과연 언제 이런게 가능할까 고민 했었던 기억이 난다. cloud를 위한 linux custom 배포판 등은 <a href="http://crowbar.github.io/">crowbar</a>과 같은 프로젝트들에서 진행이 되고 있었으나 container가 아닌 이상은 이런 하이퍼바이저들을 지속적으로 교체하기엔 큰 부담이 있었다.</p>

<p>컨테이너 기술이 발전하며 이런 immutable한 이미지를 만들기 위한 여러가지 방법론들이 있었으나 개인적인 취향이나 상황에 맞게 쓸만하지 못했으나 최근 시간이 남아서 새롭게 조사하다 linuxkit이 많은 안정화를 가져온것을 확인해서 삽질을 시작했다.</p>

<h1 id="linuxkit">linuxkit<a href="#linuxkit" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p><figure>
    <img src="http://www.adelzaalouk.me/assets/linuxkit_post//linuxkit.png"/> 
</figure>

FROM <a href="http://www.adelzaalouk.me/2017/moby-linuxkit/">Demystifying Moby: From OCI to Linuxkit</a></p>

<p><strong><a href="https://github.com/linuxkit/linuxkit">linuxkit</a></strong> 은 아주 간단히 말해서 컨테이너를 위한 커스텀 리눅스 배포판을 만들고, 배포하고, 실행하기 위한 툴이다.</p>

<p>단도직입적으로 linuxkit을 선호해서 사용하고 하는 이유는 다음과 같다.</p>

<ul>
<li>블럭을 쌓는것처럼 kernel 부터 모두 <code>docker image</code>이다.</li>
<li>한가지 <code>yaml</code> 작성으로 로컬 하이퍼바이저(qemu, xhyve, &hellip;), 클라우드(gcp, aws, &hellip;), 베어마탈을 위한 Pxe들을 지원 가능하다.</li>
<li><code>immutable</code>한 이미지 이다.</li>
<li>내가 설정한 것외에는 <code>아무것도 존재 하지 않아서</code> 보안적으로 뛰어나다.</li>
</ul>

<p>물론 이런 장점은 이런 단점으로 볼 수도 있다.</p>

<ul>
<li>블럭을 쌓는거에따라 조합이 L * M * N 과 같이 늘어나면서 안되는 경우의 수가 많아 테스트가 중요해진다.</li>
<li>한가지 yaml으로 모든걸 지원하기 위해 지원하는 플랫폼에 대한 코드의 준비나 테스트가 필요하다.</li>
<li>immutable 하다고 해도 외부 요인이 있는한 (eg. 컨테이너 이미지 다운로드) 문제가 생길 가능성은 충분히 남아 있다.</li>
<li>이미지가 배포된뒤에 디버깅 할 수 있는 수단이 아주 제한적이다.</li>
</ul>

<p>간단한 예제들이 많이 있으니 직접 돌려보면 이해가 쉬울 것 같다.</p>

<h3 id="kubernetes를-좀-더-쉽게-관리하려면">kubernetes를 좀 더 쉽게 관리하려면<a href="#kubernetes를-좀-더-쉽게-관리하려면" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<figure>
    <img src="/images/module_01_cluster.svg"/> <figcaption>
            <h4>kubernetes</h4>
        </figcaption>
</figure>


<p>From <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using Minikube to Create a Cluster
</a></p>

<p>kubernetes를 관리한다고 생각하면 수많은 오퍼레이션을 생각하게 되지만 만약 배포를 간단하게 만든다면(eg. golden image, linuxkit 등) 생각보다 많은 어려운 작업들을 심플하게 만들 수 있다. 예를 들면 다음과 같다.</p>

<h4 id="전통적인-kubernetes-upgrade-방법">전통적인 kubernetes upgrade 방법<a href="#전통적인-kubernetes-upgrade-방법" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>예를 들어서 <a href="https://kubernetes.io/docs/tasks/administer-cluster/upgrade-downgrade/kubeadm-upgrade-1-9/">kubernetes upgrade</a>는 크게 2가지로 이루어져 있다.</p>

<ol>
<li><code>control plane(apiserver, controller manager, scheduler)</code> upgrade

<ul>
<li><code>kubeadm</code>같은 툴을 사용하지 않고 master HA해서 사용하게 된다면 결국 master노드 하나씩 drain 이후 static pod들의 manifest를 수정해서 업그레이드 한후 다시 투입(uncordon) 시킨다.</li>
</ul></li>
<li><code>node agent(kubelet)</code> upgrade

<ul>
<li>drain 이후 kubelet version upgrade 이후 다시 노드를 투입(uncordon)해야 한다.</li>
</ul></li>
</ol>

<p>위와 같은 작업을 하게되면 새로추가되는 노드는 필요없지만 <code>migration 비용이 크고</code>, <code>작업이 길어지고</code>, <code>롤백이 힘들어지고</code>, <code>과거로부터 지속된 업그레이드로 인한 문제(A-&gt;B-&gt;C 로 업그레이드 한것과 B-&gt;C 만 업그레이드한것이 다른 경우)</code> 등에서 자유롭지 못하다.</p>

<h4 id="노드-추가를-통한-kubernetes-upgrade-방법">노드 추가를 통한 kubernetes upgrade 방법<a href="#노드-추가를-통한-kubernetes-upgrade-방법" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<ol>
<li><p><code>control plane(apiserver, controller manager, scheduler)</code> upgrade</p>

<ul>
<li>control plane은 새로운 static pod이 있는 master node를 추가한 뒤 과거 버전의 master node를 제거(drain) 하는 식으로 업그레이드가 가능하다.</li>
</ul></li>

<li><p><code>node agent(kubelet)</code> upgrade</p>

<ul>
<li>node agent도 비슷하게 새로운 버전의 노드들을 가능한 만큼 추가 하고 이전 버전 노드들을 <code>cordon</code> 시킨 상태에서 낮은 버전의 노드들을 제거(drain) 혹은 새로운 버전 노드로 재설치해서 사용하는식으로 업그레이드 가능하다.</li>
</ul></li>
</ol>

<p>여기서도 결국 master와 node의 2종류의 이미지를 관리해야 한다. 물론 모두 master 이미지로 만들고 node로 사용가능하나 깔끔하진 못한 방법이다. 이런걸 해결 하기 위해서는 결국 <strong><a href="https://schd.ws/hosted_files/kccncna17/50/Self-Hosted%20Kubernetes_%20How%20and%20Why.pdf">self hosted kubernetes</a></strong> 를 고려해야 한다.</p>

<p><strong>self hosted kubernetes</strong> 를 이용하게 되면 master node의 라벨을 같는 node가 master의 역할을 수행할뿐(apiserver, controller manager, scheduler를 갖는 node) 모두 동일한 node로 구성 가능하다. self hosted kubernetes는 아직 alpha state이나 나중에 이게 default가 되기때문에 미리 봐도 좋을것 같다. 이걸 적용하면 upgrade 절차는 더욱 단순해 진다.</p>

<ol>
<li><p><code>control plane(apiserver, controller manager, scheduler)</code> upgrade</p>

<ul>
<li>control plane은 apiserver는 daemonset, controller manager, scheduler는 deployment가 되기 때문에 image 교체정도로 업그레이드가 끝나게 된다.</li>
</ul>

<pre><code>kubectl set image ds/kube-apiserver \
    kube-apiserver=gcr.io/google_containers/kube-apiserver-amd64:v1.10.0
kubectl set image deploy/kube-scheduler \
    kube-scheduler=gcr.io/google_containers/kube-scheduler-amd64:v1.10.0
kubectl set image deploy/kube-controller-manager \
    kube-controller-manager=gcr.io/google_containers/kube-controller-manager-amd64:v1.10.0
</code></pre></li>

<li><p><code>node agent(kubelet)</code> upgrade</p>

<ul>
<li>일반과 동일</li>
</ul></li>
</ol>

<p>즉, <code>self hosted kubernetes</code>를 적용하면 master와 node 이미지를 별개로 이미지를 준비하고, 작업을 따로 준비 하지 않아도 된다. 결국 node image만 준비하면 되고 이건 kubelet agent들이 있는 이미지만 준비하면 된다는 것이다.</p>

<h3 id="에스칼레이터-발판-같은-kubernetes-노드-관리">에스칼레이터 발판 같은 kubernetes 노드 관리<a href="#에스칼레이터-발판-같은-kubernetes-노드-관리" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<figure>
    <img src="http://www.madehow.com/images/hpm_0000_0003_0_img0050.jpg"/> <figcaption>
            <h4>escalator</h4>
        </figcaption>
</figure>


<p>From <a href="http://www.madehow.com/Volume-3/Escalator.html">Escalator Background</a></p>

<p>앞서 설명한 글을 보다 자세히 설명하기 위해서 에스칼레이터의 그림을 가져왔다.
에스칼레이터의 발판은 무한으로 생성되는 것이 아닌 사용된 발판이 사용되고 다시 한바퀴 돌아 재사용되는 식으로 사람을 옮기게 된다.</p>

<p>앞에서 kubernetes upgrade를 통해서 설명하려고 한것도 이와 비슷하게 kubernetes node도 이런 life cycle을 갖게한다고 보면 된다.</p>

<figure>
    <img src="/images/swapable-w.png"/> <figcaption>
            <h4>swapable nodes</h4>
        </figcaption>
</figure>


<p>즉, 에스칼레이터나 캐터필러와 같이 계속 업그레이드, docker version 업데이트등과 같은 작업이나 확장등은 신규 노드를 추가하고 옛날 노드를 삭제한다. 그래서 여기에 사용되는 노드들을 빠르게 추가하고 안전하게 관리하기 위해서 linuxkit과 같은 immutable한 이미지 사용을 고려했다.</p>

<h1 id="linuxkit-kubernetes">linuxkit + kubernetes<a href="#linuxkit-kubernetes" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p><a href="https://github.com/leoh0/kubernetes">leoh0/kubernetes</a></p>

<p>그렇다면 linuxkit으로 kubernetes를 배포하려면 어떤걸 고려하고 어떻게 해야되나를 생각해보면 다음과 같다.</p>

<p>우선 linuxkit으로 돌리려면 minikube와 같은 allinone 솔루션이 아니라 (거의)무조건 멀티노드를 전제하게 된다. 이를 위해서 기본적으로 cni를 통한 <code>weave</code>를 지원하도 있다. 하지만 다양한 network등을 적용해 볼 수 있다. 나 같은 경우엔 <code>calico</code>와 <code>cilium</code>등을 이용해서 배포하는 것들을 테스트 했다.</p>

<p>그렇다면 어디에 배포할 수 있는 가는 내가 테스트 해본것은 우선 <code>mac(xhyve)</code>, <code>qemu(ubuntu)</code>, <code>gcp</code>, <code>aws</code> 에서 였다. 앞서 말한것 처럼 사실 각각에서 되고 안되고가 있기때문에 각각에 대한 주의사항이나 사용경험등을 공유한다. 우선 전체적으로 <code>4.9.78</code> 정도의 커널을 사용하는게 현재까지 가장 stable 하고 성공확률이 높다.</p>

<p>물론 이것을 보더라도 만약 이런 정보들이 처음이면 삽질하는데 엄청난 시간이 들어갈 수 밖에 없다. 왜냐하면 우선 debug할 수 있는 수단이 제한적이고 모든 것이 컨테이너이기 때문에 각각이 네임스페이스에 갇혀있고 디스크의 마운트 구조를 이해하지 못하면 어떤 파일들이 어디에 있는지 조차도 파악하기가 힘들다. 하지만 모든건 시간이 해결 해 줄 것이다.</p>

<h2 id="사용-가능한-platform들">사용 가능한 platform들<a href="#사용-가능한-platform들" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<h3 id="mac-xhyve">mac(xhyve)<a href="#mac-xhyve" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>만약 mac이 있다면 우선 제일 쉽게 시작할 수 있다. <code>brew</code>나 <code>go</code>를 통해서 binary(linuxkit)을 쉽게 얻을 수 있고 설치 생성시 바로 성공을 경험 할 수 있다. <a href="https://github.com/linuxkit/kubernetes">README</a> 대로 따라하면 된다.</p>

<p>하지만 거기 까지다.</p>

<p>그 이상을 할 수가 없다는 것을 알게 된다. 만약 본인이 L2 네트워크나 L3 네트워크를 컨트롤 하고 싶어져도, hyperkit과 vpnkit을 조작할 수 없고 심지어 dhcp 도 컨트롤 할 수 없다는 사실이 답답하게 느껴질 것이다. 그리고 또한 호스트의 16G 정도의 메모리로는 4G instance를 2-3개 정도 밖에 못쓴다. 4G 메모리가 필요한 이유는 cilium를 사용할 때이며 이때 eBPF map을 관리하는데 4G 정도가 들어가기 때문이다. 물론, calico나 weave를 쓰면 더 많은 노드를 띄울 수 있다.</p>

<h3 id="qemu-ubuntu">qemu(ubuntu)<a href="#qemu-ubuntu" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>사실 메모리가 많은 하이퍼바이저만 구할 여유가 된다면 이 방법이 가장 좋을 수도 있다. 물론 하지만 본인이 linux의 internel network을 조작하는데 익숙 하지 않다면 간단하지 않을 수 있다. <a href="https://github.com/linuxkit/kubernetes#linux">README</a>에 설명되어 있으나 저정도로는 간단하지 않다. 특히 qemu로 띄웠을때는 서로 vm들끼리 공유되지 않는 네트워크 상태이지 않기때문에 아래같은 스크립트로 internel network을 생성해서 사용해야 한다.</p>

<p>그래서 아래의 스크립트를 참고해서 네트워크를 만든다. 아래 스크립트를 설명하면 다음과 같은 일 들을 한다.</p>

<ol>
<li><code>docker</code>, <code>qemu</code>, <code>golang</code> 설치</li>
<li>vm이 사용할 bridge 생성 및 이에 대한 dhcp 설정</li>
<li>해당 bridge의 vm이 nat로 인터넷 연결 할 수 있도록 설정</li>
<li>linuxkit 설치 및 접속할 sshkey 생성</li>
</ol>

<pre><code class="language-bash">#!/bin/sh

if [ &quot;$(id -u)&quot; != &quot;0&quot; ]; then
   echo &quot;This script must be run as root&quot; 1&gt;&amp;2
   exit 1
fi

set -ex

apt update
apt install   -y  apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
apt-key fingerprint 0EBFCD88
#add-apt-repository    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
#   $(lsb_release -cs) \
#   stable&quot;
# 18.04는 repo가 아직 없어서 artful을 이용해야 한다.
add-apt-repository    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   artful \
   stable&quot;
apt update
apt install -y docker-ce uml-utilities qemu-kvm bridge-utils virtinst libvirt-bin golang-go

virsh net-destroy default
virsh net-autostart --disable default

ip link add virbr10-dummy address $(hexdump -vn3 -e '/3 &quot;52:54:00&quot;' -e '/1 &quot;:%02x&quot;' -e '&quot;\n&quot;' /dev/urandom) type dummy

brctl addbr virbr10
brctl stp virbr10 on
brctl addif virbr10 virbr10-dummy
ip address add 10.0.0.1/8 dev virbr10 broadcast 192.168.100.255

echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf
echo &quot;net.ipv4.conf.all.forwarding=1&quot; &gt;&gt; /etc/sysctl.conf
sysctl -p

iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -d 224.0.0.0/24 -j RETURN
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -d 255.255.255.255/32 -j RETURN
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -p tcp -j MASQUERADE --to-ports 1024-65535
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -p udp -j MASQUERADE --to-ports 1024-65535
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE

iptables -t filter -A FORWARD -d 10.0.0.0/8 -o virbr10 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# 밖으로(169.254.0.0/16)으로 메타가 새면 하이퍼바이저의 메타를 들고온다..
iptables -t filter -A FORWARD -s 10.0.0.0/8 ! -d 169.254.0.0/16 -i virbr10 -j ACCEPT
iptables -t filter -A FORWARD -s 10.0.0.0/8 -d 169.254.0.0/16 -i virbr10 -j DROP

ip l set virbr10-dummy up
ip l set virbr10 up

mkdir -p /etc/qemu/
echo 'allow virbr10' &gt; /etc/qemu/bridge.conf
mkdir -p /var/lib/dnsmasq/virbr10
touch /var/lib/dnsmasq/virbr10/hostsfile
touch /var/lib/dnsmasq/virbr10/leases

cat &gt; /var/lib/dnsmasq/virbr10/dnsmasq.conf &lt;&lt; EOF
# Only bind to the virtual bridge. This avoids conflicts with other running
# dnsmasq instances.
except-interface=lo
interface=virbr10
bind-dynamic

# If using dnsmasq 2.62 or older, remove &quot;bind-dynamic&quot; and &quot;interface&quot; lines
# and uncomment these lines instead:
#bind-interfaces
listen-address=10.0.0.1

# IPv4 addresses to offer to VMs. This should match the chosen subnet.
dhcp-range=10.0.0.2,10.15.255.254

# 굳이 안해도 되나 아이피 일괄적으로 주려면 이런게 제일 편하다.
dhcp-host=8a:a0:33:57:08:0a,10.0.0.2
dhcp-host=8a:a0:33:57:08:0b,10.0.0.3
dhcp-host=8a:a0:33:57:08:0c,10.0.0.4
dhcp-host=8a:a0:33:57:08:0d,10.0.0.5
dhcp-host=8a:a0:33:57:08:0e,10.0.0.6

# Set this to at least the total number of addresses in DHCP-enabled subnets.
dhcp-lease-max=1000

# File to write DHCP lease information to.
dhcp-leasefile=/var/lib/dnsmasq/virbr10/leases
# File to read DHCP host information from.
dhcp-hostsfile=/var/lib/dnsmasq/virbr10/hostsfile
# Avoid problems with old or broken clients.
dhcp-no-override
# https://www.redhat.com/archives/libvir-list/2010-March/msg00038.html
strict-order
EOF

cat &gt; /etc/systemd/system/dnsmasq@.service &lt;&lt; EOF
# '%i' becomes 'virbr10' when running `systemctl start dnsmasq@virbr10.service`
# Remember to run `systemctl daemon-reload` after creating or editing this file.

[Unit]
Description=DHCP and DNS caching server for %i.
After=network.target

[Service]
ExecStart=/usr/sbin/dnsmasq -k --conf-file=/var/lib/dnsmasq/%i/dnsmasq.conf
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
systemctl start dnsmasq@virbr10.service

echo '''Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    User root''' &gt; /root/.ssh/config

export PATH=~/go/bin:$PATH
export PATH=/usr/libexec:$PATH

echo '''export PATH=~/go/bin:$PATH
export PATH=/usr/libexec:$PATH''' &gt;&gt; ~/.bashrc

git clone https://github.com/leoh0/kubernetes

go get -u github.com/linuxkit/linuxkit/src/cmd/linuxkit

echo -e &quot;\n\n\n&quot; | ssh-keygen -t rsa -N &quot;&quot;

echo '''
# cd /root/kubernetes
make all
KUBE_CLEAR_STATE=true KUBE_MAC=8a:a0:33:57:08:0a KUBE_NETWORKING=&quot;bridge,virbr10&quot; ./boot.sh
KUBE_CLEAR_STATE=true KUBE_MAC=8a:a0:33:57:08:0b KUBE_NETWORKING=&quot;bridge,virbr10&quot; ./boot.sh 1 \
    10.0.0.2:6443 --token 3wkfov.fj3ywmkva55nr4p7 --discovery-token-ca-cert-hash \
    sha256:ee14b16af5775cfa65215cff0f6fe2807d35b23a4a3dd8a72507e93292fcd8f1
'''
</code></pre>

<p>이와 같은 설치시 내부 네트워크 조작등 가장 강력하게 테스트를 해볼수 있다.
다만 큰 메모리에 하이퍼바이저를 구하기가 쉽지 않을 수 있다. 현재로서는 gce에서 요새 <a href="https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances">nested-virtualization</a>
을 지원하는 vm을 만들 수 있어서 이곳이 가장 용의 할 것 같다.</p>

<h3 id="gcp">gcp<a href="#gcp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>구글 클라우드 플랫폼은 설정만 다 되면 쓰기에 좋은 편이다. 현재 커널 4.14.x가 동작하지 않는것만 알면 우선 작동이 어렵진 않다. 다만 작은 문제들이 있는데 예를 들면 다음과 같다.</p>

<ol>
<li><p>linuxkit에서는 현재 이미지이름과 같은 vm을 생성한다. gcp에서는 호스트네임이 유니크 해야되서 이때문에 node들은 일부러 이미지를 이름을 다르게 해서 올려야 한다. 예를 들어 아래처럼 01 02 03 과 같이 이름을 다르게 써야 한다.</p>

<pre><code>linuxkit push gcp -project alproj -bucket linuxkital \
    -img-name cilium-kube-node01 cilium-kube-node.img.tar.gz
linuxkit run gcp -project alproj -keys 'key.json' \
    -zone asia-east1-c -machine n1-standard-2 -disk 10 cilium-kube-node01

linuxkit push gcp -project alproj -bucket linuxkital \
    -img-name cilium-kube-node02 cilium-kube-node.img.tar.gz
linuxkit run gcp -project alproj -keys 'key.json' \
    -zone asia-east1-c -machine n1-standard-2 -disk 10 cilium-kube-node02
</code></pre></li>

<li><p>생성할때 disk를 추가해 줘야 한다. 이건 문제라기 보단 당연한 건데 gcp, aws들은 이미지를 raw타입을 쓰고 이미지의 사이즈에서 resize(<a href="https://github.com/linuxkit/linuxkit/tree/master/pkg/extend">extend</a> 하지 않으면 디스크 사이즈가 아예 없다고 봐도 된다. 그래서 추가디스크(eg. sdb)로 용량을 확보(eg. docker image가 저장되는 /var/lib 등)해서 사용 할 수 있다.</p></li>

<li><p>metadata를 linuxkit command로 넣을 수 없다.. 아직 기능부족으로 문제가 된다. 수동으로 <code>kubeadm join</code> 커맨드를 돌려서 작동 시킬 수 있다. 하지만 <code>kubeadm join</code>커맨드를 돌리면 <code>/etc/kubernetes/bootstrap-kubelet.conf</code> 만 생성된다. 원래 kubelet이 떠있으면 이 파일이 생성되면서 자동으로 kubelet이 이파일로 노드 등록을 하게 되나 linuxkit은 kubelet service가 systemd 등과 같은 툴로 실패해도 지속적으로 구동되도록 트라이 하지 못함으로 특정 파일이 생길때까지 wait을 해놓은 상태이다. 그래서 특정 파일을 생성해 줘야 kubelet 서비스가 뜰 수 있다. 이걸 코드로 표현 하면 다음과 같다.</p></li>
</ol>

<pre><code>kubeadm join 10.140.0.2:6443 \
    --ignore-preflight-errors=all \
    --token gitpj4.gtok7zsm3tfrlh64 \
    --discovery-token-ca-cert-hash sha256:773e83472b9809473cde237246227dfc2cd795a5848f127de11b3a5fb6550fb9
touch /etc/kubernetes/kubelet.conf
</code></pre>

<h3 id="aws">aws<a href="#aws" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>aws는 결론만 놓고 이야기 했을때 현재 성공하지 못했다. 마지막으로 확인한것은 모든 network acl을 풀었으나 kubelet 노드의 apiserver에 대한 request들이 실패하는 로그들과 함께 실패했다. 다만 4.14.x 대역의 커널도 지원하고 있어서 삽질을 더 하면 사용가능 할 듯 하다. 여기도 추가적인 문제점은 다음과 같다.</p>

<ol>
<li><p>image의 overwrite가 안된다. 옵션으로 풀수 있을지 모르지만 AMI를 등록 취소시키고 다시 하는 방법만으로 사용했다.</p></li>

<li><p>gcp와 같이 디스크 추가가 반듯이 필요하다.</p></li>

<li><p>metadata도 현재 사용 불가능 하다.</p></li>
</ol>

<h2 id="사용가능한-네트워크-구조들">사용가능한 네트워크 구조들<a href="#사용가능한-네트워크-구조들" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<h3 id="weave">weave<a href="#weave" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>weave는 아무런 준비없이 사용하기 좋은 터널링 네트워크이다. 다만 현재 <a href="https://github.com/linuxkit/kubernetes/issues/80">4.14.39 커널까지는 vxlan interface에 문제가 있어서 멀티노드로 띄울 시 문제</a>가 있다. 그래서 현재 패치를 제출한 상태인데 아직 머지는 안된 상태이다. 커널을 4.14.40 이상이면 vxlan 문제는 해결 된다.</p>

<h3 id="calico">calico<a href="#calico" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>calico는 역시 weave 다음으로 설정이 간단하다. 다만 weave와 달리 calico 부터는 네트워크의 메터데이터 저장이 필요하고 이 때문에 <code>etcd</code> 혹은 <code>K8S Custom resource definition</code>가 필요하다. 이 때문에 모든 노드에서 접근 가능한 etcd 설정이 필요하다. 하지만 kubeadm으로 설정시 아직은 127.0.0.1과 같이 etcd가 설치되기때문에 <a href="https://github.com/leoh0/kubernetes/blob/master/pkg/kubelet/kubeadm-init.sh#L17-L59">멀티노드에서 접근 가능한 etcd가 미리 준비</a>되어야 한다. 이걸 staticpod으로 생성시켜 kubeadm 에서 생성되지 않고 bypass 하도록 구성시켜야 한다. 이후엔 메모리도 적은 간편하고 성능 좋은 네트워크를 갖을 수 있다.</p>

<h3 id="cilium">cilium<a href="#cilium" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>cilium은 eBPF를 구동시켜보고 싶은 분들에게는 아주 희망적이고 간단한 테스트 방법이 될거라고 생각한다. 다만 노드당 4G이상의 메모리가 필요하다는것 그리고 cilium의 docker 이미지가 ubuntu base 이기 때문에 <a href="https://github.com/leoh0/cilium/commit/3c71dec31e970a9e48bfa4f80f2fd30cc13f24c4">alpine base 의 이미지</a>의 바이너리가 필요하다. 왜냐하면 이 바이너리를 cilium-node에서 node로 복사해서 해당 cni를 사용할 수 있게 해주기 때문이다. 또한 etcd가 필요하기에 etcd를 멀티노드에서 접근 가능한 방법으로 구성해야 한다.</p>

<h1 id="demo">demo<a href="#demo" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>linuxkit + kubernetes + cilium을 mac에서 테스트한 것 입니다.</p>

<p><a href="https://asciinema.org/a/182500?autoplay=1"><figure>
    <img src="https://asciinema.org/a/182500.png"/> <figcaption>
            <h4>demo</h4>
        </figcaption>
</figure>
</a></p>

<h1 id="마지막으로">마지막으로<a href="#마지막으로" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>사실 아직까지 production에 사용하는 것은 여러가지로 한계들이 충분히 있습니다. 왜냐하면 저희가 가지고 있는 환경들도 제약적인 부분들이 많기에 힘든부분들이 많다고 생각합니다. 하지만 조금더 후엔 기존에 rpm으로 kubernetes package가 나오는것들이 이런 이미지 형태로 kubernetes 에서 제공될것이라고 생각합니다. 그때에서도 이런 부분들이 충분히 실험적일 수도 있지만 인프라가 가야하는 방향중에 한가지라고 생각하기에 제가 한달간 조사하고 삽질 한것을 많은 분들게 공유하려고 정리 했습니다.</p>

<p>개인적으로 기존 제가 테스트 할때 사용하는 클러스터는 이런 방식으로 전환해서 사용하려고 계획하고 있습니다. 사용하면 할 수록 매력적인 부분들이 있는것 같네요. 다른 분들도 이런 즐거움을 느낄 수 있었으면 좋겠습니다.</p>

		</div>
		<div id="comments" class="thin">
			
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leoh0githubio" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://leoh0.github.io/"></a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://leoh0.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://leoh0.github.io/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js" integrity="sha256-eEQX9YRxUfhIwznPCssToGy7ZIsUg0NaKO1FVsTq1ps="></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-46519012-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
